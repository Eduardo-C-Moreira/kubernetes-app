# ==========================================================
#      CONFIGURAÇÃO GLOBAL — IMAGEM PADRÃO DO PIPELINE
# ==========================================================
# Esta imagem só será usada por jobs que NÃO definirem sua
# própria imagem. O job de deploy usará docker para build/push.
image: docker:latest

stages:
  - build
  - test
  - package
  - deploy


# ==========================================================
#                          BUILD
# ==========================================================
build:
  stage: build

  # Imagem com Maven + Java 17
  image: maven:3.9.6-eclipse-temurin-17

  # Executa ANTES do script — apenas em jobs Maven
  before_script:
    - echo "Java instalado:"
    - java -version           # Confirma versão do Java
    - echo "Maven instalado:"
    - mvn -version            # Confirma versão do Maven

  script:
    - echo "Atualizando versão automaticamente..."

    # Atualiza a versão do pom.xml para algo como:
    # 1.0.<PIPELINE_ID>-<SHORT_SHA>
    - mvn versions:set -DnewVersion=1.0.$CI_PIPELINE_IID-$CI_COMMIT_SHORT_SHA

    # Executa build (gera .jar) sem rodar testes
    - mvn clean package -DskipTests

  artifacts:
    paths:
      - target/*.jar    # Guarda o jar para as próximas etapas
      - pom.xml         # Guarda o pom.xml atualizado


# ==========================================================
#                          TEST
# ==========================================================
test:
  stage: test
  image: maven:3.9.6-eclipse-temurin-17

  before_script:
    - java -version
    - mvn -version

  script:
    # Executa todos os testes unitários
    - mvn test



# ==========================================================
#                         PACKAGE
# ==========================================================
package:
  stage: package
  image: maven:3.9.6-eclipse-temurin-17

  before_script:
    - java -version
    - mvn -version

  script:
    - echo "Versão final detectada:"
    # Mostra a versão final do projeto (do pom.xml)
    - mvn help:evaluate -Dexpression=project.version -q -DforceStdout

  artifacts:                     # <-- CORREÇÃO: precisa ser HASH
    paths:
      - target/*.jar             # Mantém jar para o deploy



# ==========================================================
#                         DEPLOY
# ==========================================================
docker_push:
  stage: deploy
  image: docker:latest

  # Permite rodar docker build/push dentro do runner
  services:
    - docker:dind

  script:
    # Localiza o JAR gerado no build/package
    - export JAR_FILE=$(ls target/*.jar | head -n 1)
    - echo "Arquivo gerado: $JAR_FILE"

    # Extrai a versão a partir do nome do jar (ajuste regex se necessário)
    - export PROJECT_VERSION=$(basename "$JAR_FILE" .jar | sed -E 's/.*-([0-9]+\.[0-9]+\.[^-]+).*/\1/')
    - echo "Versão extraída: $PROJECT_VERSION"

    # Monta o nome completo da imagem Docker
    - export IMAGE_FULL_TAG="$DOCKER_IMAGE_NAME:$PROJECT_VERSION"
    - echo "Tag final: $IMAGE_FULL_TAG"

    # Login no Docker Hub — variáveis devem estar no GitLab CI/CD
    - echo "Login no Docker Hub..."
    - docker login -u "$DOCKER_USERNAME" -p "$DOCKER_PASSWORD"

    # Build da imagem Docker usando o Dockerfile da raiz
    - docker build -t "$IMAGE_FULL_TAG" .

    # Envia imagem com a tag da versão
    - docker push "$IMAGE_FULL_TAG"

    # Atualiza a tag "latest"
    - docker tag "$IMAGE_FULL_TAG" "$DOCKER_IMAGE_NAME:latest"
    - docker push "$DOCKER_IMAGE_NAME:latest"

  needs:
    - package

  rules:
    - if: $CI_COMMIT_BRANCH == "master"   # Só roda no branch master
